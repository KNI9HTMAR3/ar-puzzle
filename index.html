<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AR.js 3×3 Sliding Puzzle</title>

    <!-- A-Frame (for WebXR / 3D rendering) -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>

    <!-- AR.js for A-Frame (marker tracking, etc.) -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      /* Simple button styling */
      #shuffleButton {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 999;
        padding: 0.5em 1em;
        font-size: 1rem;
      }
    </style>
  </head>
  <body>
    <!-- A button to shuffle the puzzle -->
    <button id="shuffleButton">Shuffle</button>

    <!-- A-Frame Scene with AR.js -->
    <a-scene
      embedded
      arjs="sourceType: webcam; debugUIEnabled: false;"
      cursor="rayOrigin: mouse;"
    >
      <!-- Marker-based AR (using 'hiro' preset for convenience) -->
      <a-marker preset="hiro">
        <!-- Our puzzle container entity -->
        <a-entity id="puzzle-board"></a-entity>
      </a-marker>

      <!-- AR.js requires a camera in the scene -->
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      /*******************************************************
       * 3×3 Sliding Puzzle in AR
       *******************************************************/

      // Puzzle parameters
      const PUZZLE_SIZE = 3; // 3×3 grid
      const TILE_SIZE = 0.1; // each tile’s width/height in AR units

      // The puzzle state is a flat array of length 9:
      // [1,2,3,4,5,6,7,8,0] => 0 is empty slot
      // This example starts in a solved state; we’ll shuffle on load or via the button.
      let puzzleState = [1, 2, 3, 4, 5, 6, 7, 8, 0];

      document.addEventListener("DOMContentLoaded", () => {
        // Create the puzzle tiles in the scene
        createPuzzleTiles();
        // Shuffle once at startup (optional)
        shufflePuzzle();
        // Reflect the puzzle positions in A-Frame
        updatePuzzleVisuals();

        // Button to shuffle
        document
          .getElementById("shuffleButton")
          .addEventListener("click", () => {
            shufflePuzzle();
            updatePuzzleVisuals();
          });
      });

      /**
       * Create all tile entities (except the empty one).
       * Attach them under the #puzzle-board entity.
       */
      function createPuzzleTiles() {
        const puzzleBoardEl = document.getElementById("puzzle-board");
        puzzleBoardEl.innerHTML = ""; // clear any old elements

        for (let i = 0; i < puzzleState.length; i++) {
          const tileNumber = puzzleState[i];
          if (tileNumber === 0) continue; // skip the empty slot

          // Create an <a-plane> for each tile
          const tileEl = document.createElement("a-plane");
          tileEl.setAttribute("id", `tile-${tileNumber}`);
          tileEl.setAttribute("class", "clickable");
          tileEl.setAttribute("tile-number", tileNumber);

          // Set tile size
          tileEl.setAttribute("width", TILE_SIZE);
          tileEl.setAttribute("height", TILE_SIZE);

          // Give each tile a random color (for fun) and white text on top
          // You can swap this with images or custom textures.
          const randomColor =
            "#" + Math.floor(Math.random() * 16777215).toString(16);
          tileEl.setAttribute(
            "material",
            `color: ${randomColor}; transparent: false;`
          );

          // Add a text label on the tile
          tileEl.setAttribute(
            "text",
            `value: ${tileNumber}; color: #fff; align: center; width: 2;`
          );

          // Click/tap event -> attempt to move the tile
          tileEl.addEventListener("click", handleTileClick);

          // Attach to the board
          puzzleBoardEl.appendChild(tileEl);
        }
      }

      /**
       * Update each tile’s position in the scene according to `puzzleState`.
       */
      function updatePuzzleVisuals() {
        for (let i = 0; i < puzzleState.length; i++) {
          const tileNumber = puzzleState[i];
          // Skip the empty slot
          if (tileNumber === 0) continue;

          // Locate the tile entity
          const tileEl = document.getElementById(`tile-${tileNumber}`);
          if (!tileEl) continue;

          // Compute a position (x, y, z) in AR space based on the tile’s index
          const { x, y } = indexToPosition(i);
          tileEl.setAttribute("position", { x, y, z: 0 });
        }
      }

      /**
       * Handle a tile click: if it’s adjacent to the empty slot, swap them.
       */
      function handleTileClick(event) {
        // Identify which tile was clicked
        const tileNumber = parseInt(
          event.target.getAttribute("tile-number"),
          10
        );

        // Find the tile’s index & the empty slot’s index in puzzleState
        const tileIndex = puzzleState.indexOf(tileNumber);
        const emptyIndex = puzzleState.indexOf(0);

        // If adjacent, swap them in puzzleState
        if (isAdjacent(tileIndex, emptyIndex)) {
          [puzzleState[tileIndex], puzzleState[emptyIndex]] = [
            puzzleState[emptyIndex],
            puzzleState[tileIndex],
          ];

          // Update positions in the AR scene
          updatePuzzleVisuals();

          // Check if puzzle is solved
          if (checkSolved()) {
            alert("Puzzle Solved!");
          }
        }
      }

      /**
       * Returns true if two indices in the puzzleState array are adjacent
       * in the 3×3 grid (rowDiff + colDiff = 1).
       */
      function isAdjacent(indexA, indexB) {
        const rowA = Math.floor(indexA / PUZZLE_SIZE);
        const colA = indexA % PUZZLE_SIZE;
        const rowB = Math.floor(indexB / PUZZLE_SIZE);
        const colB = indexB % PUZZLE_SIZE;
        const rowDiff = Math.abs(rowA - rowB);
        const colDiff = Math.abs(colA - colB);
        // They’re adjacent if the sum of differences is exactly 1
        return rowDiff + colDiff === 1;
      }

      /**
       * Check if the puzzle is in solved order: [1, 2, 3, 4, 5, 6, 7, 8, 0].
       */
      function checkSolved() {
        for (let i = 0; i < 8; i++) {
          if (puzzleState[i] !== i + 1) return false;
        }
        // Last slot must be 0
        return puzzleState[8] === 0;
      }

      /**
       * Given an index in puzzleState, return a position (x, y) in AR coordinates
       * so the tiles are arranged in a 3×3 grid centered around (0,0).
       */
      function indexToPosition(index) {
        const row = Math.floor(index / PUZZLE_SIZE);
        const col = index % PUZZLE_SIZE;

        // Calculate offsets to center the puzzle around the marker
        // e.g. for a 3×3 grid, total width ~ (3 * TILE_SIZE).
        const offset = (TILE_SIZE * (PUZZLE_SIZE - 1)) / 2;

        // x: moves left-to-right; y: moves top-to-bottom
        const x = col * TILE_SIZE - offset;
        const y = -row * TILE_SIZE + offset;

        return { x, y };
      }

      /**
       * Shuffle the puzzle into a random, solvable configuration.
       */
      function shufflePuzzle() {
        let shuffled = false;
        while (!shuffled) {
          puzzleState = shuffleArray(puzzleState);
          // Only accept the shuffle if it's solvable
          if (isSolvable(puzzleState)) shuffled = true;
        }
      }

      /**
       * Standard Fisher-Yates array shuffle.
       */
      function shuffleArray(arr) {
        const newArr = arr.slice(); // copy
        for (let i = newArr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
        }
        return newArr;
      }

      /**
       * For a 3×3 puzzle, the puzzle is solvable if the number of
       * 'inversions' is even. (We ignore the empty slot for inversions.)
       */
      function isSolvable(state) {
        let inversionCount = 0;
        for (let i = 0; i < state.length; i++) {
          if (state[i] === 0) continue; // skip empty
          for (let j = i + 1; j < state.length; j++) {
            if (state[j] === 0) continue;
            if (state[i] > state[j]) inversionCount++;
          }
        }
        // If inversionCount is even, puzzle is solvable
        return inversionCount % 2 === 0;
      }
    </script>
  </body>
</html>
