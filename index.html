<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Sliding Puzzle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
      .game-ui {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        color: white;
        font-family: Arial, sans-serif;
        touch-action: manipulation;
      }

      button {
        background: #4caf50;
        border: none;
        color: white;
        padding: 15px 30px;
        border-radius: 5px;
        cursor: pointer;
        margin: 0 5px;
        font-size: 16px;
      }

      button:hover {
        background: #45a049;
      }

      .a-enter-vr, 
      .a-enter-ar {
        display: none;
      }
    </style>
  </head>

  <body style="margin: 0; overflow: hidden">
    <div class="game-ui">
      <button onclick="shufflePuzzle(25)">Shuffle</button>
      <button onclick="resetPuzzle()">Reset</button>
    </div>

    <a-scene
      embedded
      arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
      renderer="logarithmicDepthBuffer: true;"
      vr-mode-ui="enabled: false"
      cursor="rayOrigin: mouse"
      raycaster="objects: .clickable"
    >
      <a-marker preset="hiro">
        <a-entity id="puzzle" position="0 0 0" scale="1 1 1">
          <a-plane
            id="tile1"
            src="./assets/puzzle-images/tile1.jpg"
            position="-0.3 0.3 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile2"
            src="./assets/puzzle-images/tile2.jpg"
            position="0 0.3 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile3"
            src="./assets/puzzle-images/tile3.jpg"
            position="0.3 0.3 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile4"
            src="./assets/puzzle-images/tile4.jpg"
            position="-0.3 0 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile5"
            src="./assets/puzzle-images/tile5.jpg"
            position="0 0 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile6"
            src="./assets/puzzle-images/tile6.jpg"
            position="0.3 0 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile7"
            src="./assets/puzzle-images/tile7.jpg"
            position="-0.3 -0.3 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="tile8"
            src="./assets/puzzle-images/tile8.jpg"
            position="0 -0.3 0"
            width="0.3"
            height="0.3"
            class="clickable"
          ></a-plane>
          <a-plane
            id="empty"
            material="color: #333333; opacity: 0.0"
            position="0.3 -0.3 0"
            width="0.3"
            height="0.3"
          ></a-plane>
        </a-entity>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      // Initial positions setup
      const initialPositions = {
        tile1: { x: -0.3, y: 0.3 },
        tile2: { x: 0.0, y: 0.3 },
        tile3: { x: 0.3, y: 0.3 },
        tile4: { x: -0.3, y: 0.0 },
        tile5: { x: 0.0, y: 0.0 },
        tile6: { x: 0.3, y: 0.0 },
        tile7: { x: -0.3, y: -0.3 },
        tile8: { x: 0.0, y: -0.3 },
        empty: { x: 0.3, y: -0.3 },
      };

      // Copy of positions for tracking
      let tilePositions = JSON.parse(JSON.stringify(initialPositions));

      // Setup event listeners
      document.addEventListener('DOMContentLoaded', function() {
        Object.keys(tilePositions).forEach((tileId) => {
          if (tileId !== "empty") {
            const tile = document.getElementById(tileId);
            
            // Touch events for mobile
            tile.addEventListener("touchstart", (e) => {
              e.preventDefault();
              moveTile(tileId);
            });

            // Click events for desktop
            tile.addEventListener("click", () => moveTile(tileId));

            // Hover effects
            tile.addEventListener("mouseenter", function () {
              const canMove = isAdjacentToEmpty(tileId);
              this.setAttribute("material", {
                color: canMove ? "#88FF88" : "#FF8888",
                opacity: 0.3,
              });
            });
            
            tile.addEventListener("mouseleave", function () {
              this.setAttribute("material", {
                color: "#FFFFFF",
                opacity: 1,
              });
            });
          }
        });
      });

      // Check if a tile is adjacent to empty space
      function isAdjacentToEmpty(tileId) {
        const emptyPos = tilePositions.empty;
        const tilePos = tilePositions[tileId];
        return (
          (Math.abs(tilePos.x - emptyPos.x) === 0.3 &&
            tilePos.y === emptyPos.y) ||
          (Math.abs(tilePos.y - emptyPos.y) === 0.3 && tilePos.x === emptyPos.x)
        );
      }

      // Move tile function
      function moveTile(tileId) {
        if (isAdjacentToEmpty(tileId)) {
          const emptyPos = tilePositions.empty;
          const tilePos = tilePositions[tileId];
          const tile = document.getElementById(tileId);
          const empty = document.getElementById("empty");

          // Animate tile movement
          tile.setAttribute("animation", {
            property: "position",
            to: `${emptyPos.x} ${emptyPos.y} 0`,
            dur: 200,
            easing: "easeInOutQuad",
          });

          // Animate empty space
          empty.setAttribute("animation", {
            property: "position",
            to: `${tilePos.x} ${tilePos.y} 0`,
            dur: 200,
            easing: "easeInOutQuad",
          });

          // Update positions
          tilePositions.empty = { ...tilePos };
          tilePositions[tileId] = { ...emptyPos };

          // Check if puzzle is solved
          checkWinCondition();
        }
      }

      // Win condition check
      function checkWinCondition() {
        const isSolved = Object.keys(tilePositions).every((id) => {
          const curr = tilePositions[id];
          const init = initialPositions[id];
          return curr.x === init.x && curr.y === init.y;
        });

        if (isSolved) {
          setTimeout(
            () => alert("Congratulations! You solved the puzzle!"),
            300
          );
        }
      }

      // Shuffle tracking
      let lastMovedTile = null;

      // Shuffle function
      function shufflePuzzle(movesCount = 20) {
        let moves = 0;
        const shuffleInterval = setInterval(() => {
          const adjacentTiles = Object.keys(tilePositions).filter(
            (id) =>
              id !== "empty" && isAdjacentToEmpty(id) && id !== lastMovedTile
          );

          if (adjacentTiles.length === 0) {
            const fallbackTiles = Object.keys(tilePositions).filter(
              (id) => id !== "empty" && isAdjacentToEmpty(id)
            );
            if (fallbackTiles.length > 0) {
              const randomTile =
                fallbackTiles[Math.floor(Math.random() * fallbackTiles.length)];
              moveTile(randomTile);
              lastMovedTile = randomTile;
            }
          } else {
            const randomTile =
              adjacentTiles[Math.floor(Math.random() * adjacentTiles.length)];
            moveTile(randomTile);
            lastMovedTile = randomTile;
          }

          moves++;
          if (moves >= movesCount) {
            clearInterval(shuffleInterval);
            lastMovedTile = null;
          }
        }, 150);
      }

      // Reset function
      function resetPuzzle() {
        Object.keys(initialPositions).forEach((tileId) => {
          const pos = initialPositions[tileId];
          document.getElementById(tileId).setAttribute("position", {
            x: pos.x,
            y: pos.y,
            z: 0,
          });
        });
        tilePositions = JSON.parse(JSON.stringify(initialPositions));
        lastMovedTile = null;
      }

      // Auto-shuffle on load
      window.addEventListener("load", () => {
        setTimeout(() => shufflePuzzle(25), 1000);
      });
    </script>
  </body>
</html>
